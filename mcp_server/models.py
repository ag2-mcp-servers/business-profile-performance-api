# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T01:05:21+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, Field, RootModel


class DailyMetric(Enum):
    DAILY_METRIC_UNKNOWN = 'DAILY_METRIC_UNKNOWN'
    BUSINESS_IMPRESSIONS_DESKTOP_MAPS = 'BUSINESS_IMPRESSIONS_DESKTOP_MAPS'
    BUSINESS_IMPRESSIONS_DESKTOP_SEARCH = 'BUSINESS_IMPRESSIONS_DESKTOP_SEARCH'
    BUSINESS_IMPRESSIONS_MOBILE_MAPS = 'BUSINESS_IMPRESSIONS_MOBILE_MAPS'
    BUSINESS_IMPRESSIONS_MOBILE_SEARCH = 'BUSINESS_IMPRESSIONS_MOBILE_SEARCH'
    BUSINESS_CONVERSATIONS = 'BUSINESS_CONVERSATIONS'
    BUSINESS_DIRECTION_REQUESTS = 'BUSINESS_DIRECTION_REQUESTS'
    CALL_CLICKS = 'CALL_CLICKS'
    WEBSITE_CLICKS = 'WEBSITE_CLICKS'
    BUSINESS_BOOKINGS = 'BUSINESS_BOOKINGS'
    BUSINESS_FOOD_ORDERS = 'BUSINESS_FOOD_ORDERS'
    BUSINESS_FOOD_MENU_CLICKS = 'BUSINESS_FOOD_MENU_CLICKS'


class DayOfWeek(Enum):
    DAY_OF_WEEK_UNSPECIFIED = 'DAY_OF_WEEK_UNSPECIFIED'
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'
    SUNDAY = 'SUNDAY'


class Date(BaseModel):
    day: Optional[int] = Field(
        None,
        description="Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.",
    )
    month: Optional[int] = Field(
        None,
        description='Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.',
    )
    year: Optional[int] = Field(
        None,
        description='Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.',
    )


class DatedValue(BaseModel):
    date: Optional[Date] = Field(
        None,
        description='The date that the datapoint corresponds to. This represents a month value if the day field is not set.',
    )
    value: Optional[str] = Field(
        None,
        description='The value of the datapoint. This will not be present when the value is zero.',
    )


class InsightsValue(BaseModel):
    threshold: Optional[str] = Field(
        None, description='Represents the threshold below which the actual value falls.'
    )
    value: Optional[str] = Field(None, description='Represents the actual value.')


class SearchKeywordCount(BaseModel):
    insightsValue: Optional[InsightsValue] = Field(
        None,
        description='One of either: 1) The sum of the number of unique users that used the keyword in a month, aggregated for each month requested. 2) A threshold that indicates that the actual value is below this threshold.',
    )
    searchKeyword: Optional[str] = Field(
        None, description='The lower-cased string that the user entered.'
    )


class TimeOfDay(BaseModel):
    hours: Optional[int] = Field(
        None,
        description='Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.',
    )
    minutes: Optional[int] = Field(
        None, description='Minutes of hour of day. Must be from 0 to 59.'
    )
    nanos: Optional[int] = Field(
        None,
        description='Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.',
    )
    seconds: Optional[int] = Field(
        None,
        description='Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.',
    )


class TimeSeries(BaseModel):
    datedValues: Optional[List[DatedValue]] = Field(
        None,
        description='List of datapoints in the timeseries, where each datapoint is a date-value pair.',
    )


class FieldXgafv(Enum):
    field_1 = '1'
    field_2 = '2'


class Alt(Enum):
    json = 'json'
    media = 'media'
    proto = 'proto'


class DailyMetrics(RootModel[List[DailyMetric]]):
    root: List[DailyMetric]


class DailySubEntityTypeDayOfWeek(Enum):
    DAY_OF_WEEK_UNSPECIFIED = 'DAY_OF_WEEK_UNSPECIFIED'
    MONDAY = 'MONDAY'
    TUESDAY = 'TUESDAY'
    WEDNESDAY = 'WEDNESDAY'
    THURSDAY = 'THURSDAY'
    FRIDAY = 'FRIDAY'
    SATURDAY = 'SATURDAY'
    SUNDAY = 'SUNDAY'


class DailySubEntityType(BaseModel):
    dayOfWeek: Optional[DayOfWeek] = Field(
        None,
        description='Represents the day of the week. Eg: MONDAY. Currently supported DailyMetrics = NONE.',
    )
    timeOfDay: Optional[TimeOfDay] = Field(
        None,
        description='Represents the time of the day in 24 hour format. Eg: 13:34:20 Currently supported DailyMetrics = NONE.',
    )


class GetDailyMetricsTimeSeriesResponse(BaseModel):
    timeSeries: Optional[TimeSeries] = Field(None, description='The daily time series.')


class ListSearchKeywordImpressionsMonthlyResponse(BaseModel):
    nextPageToken: Optional[str] = Field(
        None,
        description='A token indicating the last paginated result returned. This can be used by succeeding requests to get the next "page" of keywords. It will only be present when there are more results to be returned.',
    )
    searchKeywordsCounts: Optional[List[SearchKeywordCount]] = Field(
        None, description='Search terms which have been used to find a business.'
    )


class DailyMetricTimeSeries(BaseModel):
    dailyMetric: Optional[DailyMetric] = Field(
        None, description='The DailyMetric that the TimeSeries represents.'
    )
    dailySubEntityType: Optional[DailySubEntityType] = Field(
        None,
        description='The DailySubEntityType that the TimeSeries represents. Will not be present when breakdown does not exist.',
    )
    timeSeries: Optional[TimeSeries] = Field(
        None,
        description='List of datapoints where each datapoint is a date-value pair.',
    )


class MultiDailyMetricTimeSeries(BaseModel):
    dailyMetricTimeSeries: Optional[List[DailyMetricTimeSeries]] = Field(
        None, description='List of DailyMetric-TimeSeries pairs.'
    )


class FetchMultiDailyMetricsTimeSeriesResponse(BaseModel):
    multiDailyMetricTimeSeries: Optional[List[MultiDailyMetricTimeSeries]] = Field(
        None, description='DailyMetrics and their corresponding time series.'
    )
